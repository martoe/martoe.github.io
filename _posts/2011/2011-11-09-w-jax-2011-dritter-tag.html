---
layout: post
title: W-JAX 2011, dritter Tag
date: '2011-11-09T19:19:00.001+01:00'
author: martin
tags:
- shownotes
modified_time: '2012-04-17T00:16:02.334+02:00'
blogger_id: tag:blogger.com,1999:blog-987786588703208935.post-5212990935254984988
blogger_orig_url: http://bxm-dev.blogspot.com/2011/11/w-jax-2011-dritter-tag.html
category: dev
---

<p><font size="3"><strong>Jürgen Höller - Spring 3.1</strong></font></p> <ul> <li>Spring 3.1-GA kommt im Dezember; abgestimmt auf den Technology-Snapshot 2011 </li> <ul> <li>JavaEE-6-Server (Glassfish 3, JBoss 7, Webshere 8)  <li>Tomcat 7  <li>Cloud-Provider wie Goggle, Amazon, VMware</li></ul> <li>Environment abstraction, environment profiles </li> <ul> <li>Dieselbe Bean wird mehrfach (für unterschiedliche Umgebungen definiert), sodass die Applikation z.B. sowohl auf einem EE-Server als auch unter Tomcat deployt werden kann  <li>“beans” Tag kann geschachtelt werden</li></ul> <li>Java-based application configuration: <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a> um XML-Namespace-Funktion erweitert (z.B. <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/transaction/annotation/EnableTransactionManagement.html">@EnableTransactionManagement</a>)  <li>Cache abstraction – deklaratives Caching (<a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/annotation/Cacheable.html">@Cacheable</a>, <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/annotation/CacheEvict.html">@CacheEvict</a>; Ausführung durch Interceptor)  <li>Servlet 3.0: <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/web/WebApplicationInitializer.html">WebApplicationInitializer</a> – kann das web.xml ersetzen  <li>JPA: Package scanning ohne persistence.xml (wenn es nur <em>eine</em> Persistence-Unit gibt) - <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html">LocalContainerEntityManagerFactoryBean</a></li></ul> <p>Sidenote: Hauptmotivation für Upgrade auf Java 7 ist die VM-Performance</p> <p>Spring 3.2: Hauptthema Java EE 7 (JCache, JMS 2.0, JPA 2.1…)</p> <p><font size="3"><strong>Jürgen Höller - Komponentendesign mit Spring<br></strong></font></p> <ul> <li>Bootstrapping ohne XML: <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/index.html">AnnotationConfigApplicationContext</a>  <li>Annotations sollen beschreibenden Charakter haben. Eigene Stereotypes schreiben, um Wiederholung von Annotations (@Service, @Transactional) bzw. Annotation-Parametern zu vermeiden.  <li><a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">@Autowired</a> bei Constructors!  <li>Factory-Methoden (<a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/annotation/Bean.html">@Bean</a>) dürfen in beliebigen Komponenten vorkommen (d.h. nicht nur bei <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a>, sondern z.B. auch bei @Service)  <li><a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/annotation/Primary.html">@Primary</a> (z.B. statt immer denselben Qualifier) verwenden  <li>Configuration classes (<a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a>): Sammlung von <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/annotation/Bean.html">@Bean</a>-Methoden. Querverweise sind erlaubt!  <li>javax-Annotations können statt Spring-Annotations verwendet werden (z.B. @Inject statt <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">@Autowired</a>)  <li>Expression language: Expressions (“#{…}”) werden dynamisch ausgewertet (im Unterschied zu Placeholdern “${…}”)  <li><a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html">@Scheduled</a></li></ul> <p><strong><font size="3">Keynote: Stephen Burton - The New Generation of Enterprise Java</font></strong></p> <ul> <li>Design for Failure  <li>Enge Zusammenarbeit zwischen Dev und Ops (Bsp. Monitoring)</li></ul> <p><strong><font size="3">Sandro Guglielmin - Managing Java Applications in Production</font></strong></p> <p>Steps for dealing with a (performance) problem in production:</p> <ol> <li>Visualize the (distributed) Application and Business Transaction</li> <li>Identify what is abnormal – focus there when optimizing (no premature optimization)</li> <li>Track the business transaction flow – isolate where to optimize</li> <li>Look at diagnostics for the slow transaction (e.g. method execution times – Ops must deliver this!), optimize</li> <li>Verify optimization</li></ol> <p>(schwache Session: mostly common sense, könnte man auch in 5-10 Minuten vermitteln)</p> <p><strong><font size="3">Michael Plöd JPA/Hibernate Performance Tuning</font></strong></p> <ul> <li>Immer aktuelle JDBC-Treiber verwenden</li> <li>Fetching-Strategien: </li> <ul> <li>Batch fetching (auf Entität-Ebene): <a href="http://docs.jboss.org/hibernate/core/3.6/javadocs/org/hibernate/annotations/BatchSize.html">@BatchSize</a> (entschärft N+1-Problem)</li> <li>Subselect fetching (auf Collection-Ebene): <br><a href="http://docs.jboss.org/hibernate/core/3.6/javadocs/org/hibernate/annotations/Fetch.html">@Fetch</a>(<a href="http://docs.jboss.org/hibernate/core/3.6/javadocs/org/hibernate/annotations/FetchMode.html#SUBSELECT">FetchMode.SUBSELECT</a>)</li> <li>Eager fetching: nie bei mehr als einer Collection pro Entity! Am besten in Mappings für Collections gar nicht verwenden! (nur bei Queries)</li></ul> <li>Caching</li> <ul> <li>Bei Massenverarbeitung (Batches) regelmäßig flushen und clearen! (weil: First-Level-Cache ist in der Verantwortung des Entwicklers)</li> <li><a href="http://docs.jboss.org/hibernate/core/3.6/javadocs/org/hibernate/annotations/Cache.html">@Cache</a>, <a href="http://download.oracle.com/javaee/6/api/javax/persistence/Cacheable.html">@Cacheable</a></li> <li>Collection-Cache cacht nur die Primary Keys</li> <li>verteilte 2nd-Level-Caches nur von (Caching-/Netzwerk-)Spezialisten aufsetzen lassen!</li> <li>immer equals() und hashCode() implementieren!</li> <li>Cache konservativ konfigurieren (nur unkritische Entities mit vielen Reads, wenig Writes)</li></ul> <li>Abfragen</li> <ul> <li>früh einschränken, Projektionen verwenden</li> <li>immer Bind-Variablen verwenden!</li> <li>Query-Cache wird sehr selten benötigt</li></ul></ul> <p><strong><font size="3">Keynote: Kevlin Henney - Cool Code</font></strong></p> <p>Funny.</p>  