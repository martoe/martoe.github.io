---
layout: post
title: W-JAX 2011, fünfter Tag
date: '2011-11-11T11:37:00.001+01:00'
author: martin
tags:
- shownotes
modified_time: '2012-04-17T00:15:31.709+02:00'
blogger_id: tag:blogger.com,1999:blog-987786588703208935.post-3021907477058202746
blogger_orig_url: http://bxm-dev.blogspot.com/2011/11/w-jax-2011-funfter-tag.html
category: dev
---

<b><span style="font-size: small;">Eberhard Wolff - Spring Advanced</span></b><br /><b>1. <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CCcQFjAA&amp;url=http%3A%2F%2Fwww.springsource.org%2Fspring-roo&amp;ei=NfG8Trd6wbO3B5PyxaMG&amp;usg=AFQjCNHet2qBgX6eqBE4p5NQN0YrRGd5Gw">Spring Roo</a> (mit <a href="http://www.springsource.com/developer/sts">SpringSource Tool Suite</a>)</b><br /><b>2. Large Applications – Infrastructure</b><br /><ul><li>Infrastructure-Konfiguration von übriger Konfiguration trennen (eigene XML-Datei, PropertyPlaceholderConfigurer); besser keine Default-Werte verwenden  </li><li>Unterschiedliche Infrastructure-Beans (lazy-init) über einen Alias (mit Placeholder im Namen) <script class="brush:xml" type="syntaxhighlighter"><![CDATA[<alias name="datasource.${environment}".../><br /><bean id="datasource.javaee" class="...JndiObjectFactoryBean" lazy-init="true".../><br /><bean id="datasource.javase" class="...BasicDataSource" lazy-init="true".../>]]></script> </li><li>Spring 3.1: statt dessen Profiles verwenden  </li><li>Für In-Memory-Databases: &lt;jdbc:embedded-database/&gt; &lt;jdbc:script/&gt; (eher nicht verwenden, da sich Im-Meory-DBs oft anders als richtige DBs verhalten)</li></ul><b>3. Large Applications – Architecture</b><br />Ziel: horizontal (Layers) und vertikal (Slices) strukturiertes System (Slices sind wichtiger!) - vgl. <a href="http://www.slideshare.net/olivergierke/whoops-where-did-my-architecture-go">Slides</a><br /><ul><li>Strukturieren mit Naming Conventions: com.acme.${slice}.[dao|domain|service|web] – Problem: Sichtbarkeit  <ul><li>Component-Scan mit Naming-Convention (ohne @Service-Annotation): <script class="brush:xml" type="syntaxhighlighter"><![CDATA[<context:component-scan base-package="com.ewolff"><br /><context:include-filter type="aspectj" expression="com.ewolff..*ServiceImpl"/>]]></script> </li><li>AspectJ Dependency Management (z.B. verbotene Aufrufe zwischen den Schichten verhindern) mit @DeclareError (als Alternative zu <a href="http://www.hello2morrow.com/products/sonargraph">Sonargraph</a>/<a href="http://www.headwaysoftware.com/products/?code=Structure101">Structure101</a>)</li></ul></li><li>Strukturieren mit Annotations (@Service, @Repository...)  <ul><li>Meta-Annotations statt eine Klasse mehrfach zu annotieren</li></ul></li><li>Strukturieren mit XML  <ul><li>ein eigenes Context-XML je Layer/Slice  </li><li>Nachteil: keine Sichtbarkeitseinschränkungen, keine expliziten Abhängigkeiten  </li><li>Idee: jede Komponente als Jar-File mit fixem Context-XML, merge mit "classpath*"  </li><li>Idee: Layering <i>oder</i> Slices mittels ApplicationContext-Hierarchien</li></ul></li><li><a href="http://www.springsource.org/osgi">Spring Dynamic Modules</a> (OSGi)  <ul><li>&lt;osgi:service&gt;, &lt;osgi:reference&gt;  </li><li>Eher nicht praktikabel (sehr komplex)</li></ul></li><li>Spring Java Config</li></ul>