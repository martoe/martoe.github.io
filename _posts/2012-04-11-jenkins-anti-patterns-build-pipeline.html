---
layout: post
title: 'Jenkins Anti-Patterns: The Build Pipeline'
date: '2012-04-11T10:41:00.000+02:00'
author: martin
tags:
- CI
- jenkins
modified_time: '2012-04-11T10:41:02.291+02:00'
blogger_id: tag:blogger.com,1999:blog-987786588703208935.post-2447365622731855784
blogger_orig_url: http://bxm-dev.blogspot.com/2012/04/jenkins-anti-patterns-build-pipeline.html
---

A "build pipeline" in <a href="https://wiki.jenkins-ci.org/display/JENKINS/Terminology">Jenkins terminology</a> is a cascade of jobs, where the successful execution of one job (the "upstream build") triggers the execution of one or more other jobs (the "downstream builds").<br />I have seen such "build pipelines" very frequently, so I guess it is a kind of obvious solution to a common problem (though I am not sure what exactly this problem is…).<br />The main advantages of a build pipeline probably are:<br /><ul><li>A complex build process looks less complex if split up into several jobs  </li><li>If the build pipeline fails, it is obvious at which step (i.e. at which job) it did fail exactly </li></ul>Surprisingly, my own experiences concerning build pipelines are just the opposite: <b>Build pipelines lead to complex and hard-to-maintain CI builds</b>. I am trying to point out why this is so:<br /><br />When setting up a “good” CI build (and by “good” I mean: stable, maintainable, repeatable etc.), you should consider the following points (and each one is an argument against build pipelines):<br /><br /><h3> Preconditions</h3>Your job needs a clean database? Then clean it up as part of the job itself, and don’t hope that someone did it before. Your job may only be executed if all unit tests are passed? Then execute the tests within your job.<br />The jobs of a build pipeline usually share the same workspace, which means that every job expects the workspace to be in a certain state (and causing strange errors if it isn’t). Furthermore, it can be hard to make a build pipeline “thread-safe”.<br />A job must not rely on anything that is out of its scope. If the job needs exclusive access to a shared resource (like an application server or database instance), use the <a href="https://wiki.jenkins-ci.org/display/JENKINS/Locks+and+Latches+plugin">Locks-Plugin</a>.<br /><br /><h3> Build Triggers</h3>Every build should know why it originally has been triggered.<br />E.g. if your build is triggered by a change to the source code repository, Jenkins makes it very easy trace a failed test to the source code revision that is responsible for it.<br />If – on the other hand – your build is part of a pipeline (and therefore triggered by another build), it can be very hard to determine the changelog between two successive pipeline builds.<br /><br /><h3> Maintainability</h3>When using a build pipeline, you must ensure that<br /><ul><li>each job has a lock on the same shared resources (and the resources must no get unlocked when going downstream)  </li><li>each job has the same expiration policy  </li><li>whenever one job executes, any other job is blocked until the end of the pipeline is reached.</li></ul>These problems simply don’t exist if the build process is mapped to a single job.<br />Furthermore, a build pipeline prohibits code reuse (a job may only be part of one pipeline), which probably leads to many cut-paste jobs. A “Groovy script” build step is a good way to share code between different jobs, you don’t need a build pipeline for that.